CCS PCH C Compiler, Version 5.007, 61971               03-dez-19 11:01

               Filename:   C:\Users\IFMT\Desktop\Renan\Microcontroladores\Teclado_motor\Teclado_motor.lst

               ROM used:   2810 bytes (9%)
                           Largest free fragment is 29954
               RAM used:   61 (4%) at main() level
                           72 (5%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   088A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00C0
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... //#include <Teclado_motor.h> 
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 31,32
00B2:  DATA 33,41
00B4:  DATA 34,35
00B6:  DATA 36,42
00B8:  DATA 37,38
00BA:  DATA 39,43
00BC:  DATA 2A,30
00BE:  DATA 23,44
*
0124:  DATA 44,65
0126:  DATA 73,6C
0128:  DATA 69,67
012A:  DATA 6F,75
012C:  DATA 20,6D
012E:  DATA 6F,74
0130:  DATA 6F,72
0132:  DATA 20,73
0134:  DATA 74,65
0136:  DATA 70,0A
0138:  DATA 00,00
013A:  DATA 4D,6F
013C:  DATA 74,6F
013E:  DATA 72,2D
0140:  DATA 53,54
0142:  DATA 45,50
0144:  DATA 20,56
0146:  DATA 45,4C
0148:  DATA 3A,00
014A:  DATA 4D,6F
014C:  DATA 74,6F
014E:  DATA 72,2D
0150:  DATA 44,43
0152:  DATA 20,20
0154:  DATA 20,56
0156:  DATA 45,4C
0158:  DATA 3A,00
015A:  DATA 49,6E
015C:  DATA 69,63
015E:  DATA 69,61
0160:  DATA 6C,69
0162:  DATA 7A,61
0164:  DATA 6E,64
0166:  DATA 6F,0A
0168:  DATA 00,00
016A:  DATA 54,65
016C:  DATA 63,6C
016E:  DATA 61,20
0170:  DATA 50,72
0172:  DATA 65,73
0174:  DATA 73,69
0176:  DATA 6F,6E
0178:  DATA 61,64
017A:  DATA 61,3A
017C:  DATA 00,00
017E:  DATA 4D,6F
0180:  DATA 76,69
0182:  DATA 6D,65
0184:  DATA 6E,74
0186:  DATA 6F,20
0188:  DATA 61,6E
018A:  DATA 74,69
018C:  DATA 2D,68
018E:  DATA 6F,72
0190:  DATA 61,72
0192:  DATA 69,6F
0194:  DATA 00,00
0196:  DATA 44,65
0198:  DATA 73,6C
019A:  DATA 69,67
019C:  DATA 61,6E
019E:  DATA 64,6F
01A0:  DATA 20,6D
01A2:  DATA 6F,74
01A4:  DATA 6F,72
01A6:  DATA 20,73
01A8:  DATA 74,65
01AA:  DATA 70,0A
01AC:  DATA 00,00
01AE:  DATA 4C,69
01B0:  DATA 67,61
01B2:  DATA 6E,64
01B4:  DATA 6F,20
01B6:  DATA 6D,6F
01B8:  DATA 74,6F
01BA:  DATA 72,20
01BC:  DATA 73,74
01BE:  DATA 65,70
01C0:  DATA 0A,00
01C2:  DATA 4D,6F
01C4:  DATA 76,69
01C6:  DATA 6D,65
01C8:  DATA 6E,74
01CA:  DATA 6F,20
01CC:  DATA 68,6F
01CE:  DATA 72,E1
01D0:  DATA 72,69
01D2:  DATA 6F,00
01D4:  DATA 56,65
01D6:  DATA 6C,6F
01D8:  DATA 63,69
01DA:  DATA 64,61
01DC:  DATA 64,65
01DE:  DATA 20,73
01E0:  DATA 74,65
01E2:  DATA 70,20
01E4:  DATA 4D,69
01E6:  DATA 6E,69
01E8:  DATA 6D,61
01EA:  DATA 20,61
01EC:  DATA 6C,63
01EE:  DATA 61,6E
01F0:  DATA 63,61
01F2:  DATA 64,61
01F4:  DATA 0A,00
01F6:  DATA 44,69
01F8:  DATA 6D,69
01FA:  DATA 6E,75
01FC:  DATA 69,6E
01FE:  DATA 64,6F
0200:  DATA 20,73
0202:  DATA 74,65
0204:  DATA 70,20
0206:  DATA 76,65
0208:  DATA 6C,6F
020A:  DATA 63,69
020C:  DATA 64,61
020E:  DATA 64,65
0210:  DATA 0A,00
0212:  DATA 56,65
0214:  DATA 6C,6F
0216:  DATA 63,69
0218:  DATA 64,61
021A:  DATA 64,65
021C:  DATA 20,73
021E:  DATA 74,65
0220:  DATA 70,20
0222:  DATA 4D,61
0224:  DATA 78,69
0226:  DATA 6D,61
0228:  DATA 20,61
022A:  DATA 6C,63
022C:  DATA 61,6E
022E:  DATA 63,61
0230:  DATA 64,61
0232:  DATA 0A,00
0234:  DATA 41,75
0236:  DATA 6D,65
0238:  DATA 6E,74
023A:  DATA 61,6E
023C:  DATA 64,6F
023E:  DATA 20,73
0240:  DATA 74,65
0242:  DATA 70,20
0244:  DATA 76,65
0246:  DATA 6C,6F
0248:  DATA 63,69
024A:  DATA 64,61
024C:  DATA 64,65
024E:  DATA 0A,00
0250:  DATA 56,65
0252:  DATA 6C,6F
0254:  DATA 63,69
0256:  DATA 64,61
0258:  DATA 64,65
025A:  DATA 20,6D
025C:  DATA 61,78
025E:  DATA 69,6D
0260:  DATA 61,20
0262:  DATA 61,6E
0264:  DATA 74,69
0266:  DATA 2D,68
0268:  DATA 6F,72
026A:  DATA 61,72
026C:  DATA 69,61
026E:  DATA 20,61
0270:  DATA 6C,63
0272:  DATA 61,6E
0274:  DATA 63,61
0276:  DATA 64,61
0278:  DATA 0A,00
027A:  DATA 44,69
027C:  DATA 6D,69
027E:  DATA 6E,75
0280:  DATA 69,6E
0282:  DATA 64,6F
0284:  DATA 20,76
0286:  DATA 65,6C
0288:  DATA 6F,63
028A:  DATA 69,64
028C:  DATA 61,64
028E:  DATA 65,0A
0290:  DATA 00,00
0292:  DATA 44,65
0294:  DATA 73,6C
0296:  DATA 69,67
0298:  DATA 61,6E
029A:  DATA 64,6F
029C:  DATA 20,6D
029E:  DATA 6F,74
02A0:  DATA 6F,72
02A2:  DATA 0A,00
02A4:  DATA 4C,69
02A6:  DATA 67,61
02A8:  DATA 6E,64
02AA:  DATA 6F,20
02AC:  DATA 6D,6F
02AE:  DATA 74,6F
02B0:  DATA 72,0A
02B2:  DATA 00,00
02B4:  DATA 56,65
02B6:  DATA 6C,6F
02B8:  DATA 63,69
02BA:  DATA 64,61
02BC:  DATA 64,65
02BE:  DATA 20,6D
02C0:  DATA 61,78
02C2:  DATA 69,6D
02C4:  DATA 61,20
02C6:  DATA 68,6F
02C8:  DATA 72,61
02CA:  DATA 72,69
02CC:  DATA 61,20
02CE:  DATA 61,6C
02D0:  DATA 63,61
02D2:  DATA 6E,63
02D4:  DATA 61,64
02D6:  DATA 61,0A
02D8:  DATA 00,00
02DA:  DATA 41,75
02DC:  DATA 6D,65
02DE:  DATA 6E,74
02E0:  DATA 61,6E
02E2:  DATA 64,6F
02E4:  DATA 20,76
02E6:  DATA 65,6C
02E8:  DATA 6F,63
02EA:  DATA 69,64
02EC:  DATA 61,64
02EE:  DATA 65,0A
02F0:  DATA 00,00
02F2:  DATA 45,52
02F4:  DATA 52,4F
02F6:  DATA 21,0A
02F8:  DATA 00,00
*
048A:  TBLRD*+
048C:  MOVF   FF5,F
048E:  BZ    04A8
0490:  MOVFF  FF6,39
0494:  MOVFF  FF7,3A
0498:  MOVFF  FF5,40
049C:  RCALL  046A
049E:  MOVFF  39,FF6
04A2:  MOVFF  3A,FF7
04A6:  BRA    048A
04A8:  RETURN 0
04AA:  MOVF   41,W
04AC:  CLRF   01
04AE:  SUBWF  40,W
04B0:  BC    04B8
04B2:  MOVFF  40,00
04B6:  BRA    04D0
04B8:  CLRF   00
04BA:  MOVLW  08
04BC:  MOVWF  42
04BE:  RLCF   40,F
04C0:  RLCF   00,F
04C2:  MOVF   41,W
04C4:  SUBWF  00,W
04C6:  BTFSC  FD8.0
04C8:  MOVWF  00
04CA:  RLCF   01,F
04CC:  DECFSZ 42,F
04CE:  BRA    04BE
04D0:  RETURN 0
04D2:  MOVLW  20
04D4:  BTFSS  3B.4
04D6:  MOVLW  30
04D8:  MOVWF  3C
04DA:  MOVFF  3A,00
04DE:  BTFSS  3A.7
04E0:  BRA    04F2
04E2:  COMF   00,F
04E4:  INCF   00,F
04E6:  MOVFF  00,3A
04EA:  MOVLW  2D
04EC:  MOVWF  3C
04EE:  BSF    3B.7
04F0:  BSF    3B.0
04F2:  MOVF   01,W
04F4:  MOVFF  3A,40
04F8:  MOVLW  64
04FA:  MOVWF  41
04FC:  RCALL  04AA
04FE:  MOVFF  00,3A
0502:  MOVLW  30
0504:  ADDWF  01,W
0506:  MOVWF  3D
0508:  MOVFF  3A,40
050C:  MOVLW  0A
050E:  MOVWF  41
0510:  RCALL  04AA
0512:  MOVLW  30
0514:  ADDWF  00,W
0516:  MOVWF  3F
0518:  MOVLW  30
051A:  ADDWF  01,W
051C:  MOVWF  3E
051E:  MOVFF  3C,00
0522:  MOVLW  30
0524:  SUBWF  3D,W
0526:  BZ    0530
0528:  BSF    3B.1
052A:  BTFSC  3B.7
052C:  BSF    3B.2
052E:  BRA    0554
0530:  MOVFF  3C,3D
0534:  MOVLW  20
0536:  MOVWF  3C
0538:  MOVLW  30
053A:  SUBWF  3E,W
053C:  BZ    0546
053E:  BSF    3B.0
0540:  BTFSC  3B.7
0542:  BSF    3B.1
0544:  BRA    0554
0546:  BTFSS  FD8.2
0548:  BSF    3B.0
054A:  BNZ   0554
054C:  MOVFF  3D,3E
0550:  MOVLW  20
0552:  MOVWF  3D
0554:  BTFSC  3B.2
0556:  BRA    0562
0558:  BTFSC  3B.1
055A:  BRA    0568
055C:  BTFSC  3B.0
055E:  BRA    056E
0560:  BRA    0574
0562:  MOVFF  3C,40
0566:  RCALL  046A
0568:  MOVFF  3D,40
056C:  RCALL  046A
056E:  MOVFF  3E,40
0572:  RCALL  046A
0574:  MOVFF  3F,40
0578:  RCALL  046A
057A:  RETURN 0
*
0600:  TBLRD*+
0602:  MOVF   FF5,F
0604:  BZ    0620
0606:  MOVFF  FF6,39
060A:  MOVFF  FF7,3A
060E:  MOVF   FF5,W
0610:  BTFSS  F9E.4
0612:  BRA    0610
0614:  MOVWF  FAD
0616:  MOVFF  39,FF6
061A:  MOVFF  3A,FF7
061E:  BRA    0600
0620:  RETURN 0
*
073C:  MOVFF  FF2,0D
0740:  BCF    FF2.7
0742:  ADDWF  FE8,W
0744:  CLRF   FF7
0746:  RLCF   FF7,F
0748:  ADDLW  61
074A:  MOVWF  FF6
074C:  MOVLW  07
074E:  ADDWFC FF7,F
0750:  TBLRD*-
0752:  MOVF   FF5,W
0754:  MOVWF  FFA
0756:  TBLRD*
0758:  MOVF   FF5,W
075A:  BTFSC  0D.7
075C:  BSF    FF2.7
075E:  MOVWF  FF9
0760:  DATA 72,06
0762:  DATA 84,06
0764:  DATA 96,06
0766:  DATA A8,06
*
07BC:  MOVFF  FF2,0D
07C0:  BCF    FF2.7
07C2:  ADDWF  FE8,W
07C4:  CLRF   FF7
07C6:  RLCF   FF7,F
07C8:  ADDLW  E1
07CA:  MOVWF  FF6
07CC:  MOVLW  07
07CE:  ADDWFC FF7,F
07D0:  TBLRD*-
07D2:  MOVF   FF5,W
07D4:  MOVWF  FFA
07D6:  TBLRD*
07D8:  MOVF   FF5,W
07DA:  BTFSC  0D.7
07DC:  BSF    FF2.7
07DE:  MOVWF  FF9
07E0:  DATA 94,07
07E2:  DATA 9A,07
07E4:  DATA A0,07
07E6:  DATA A6,07
07E8:  DATA AC,07
*
0852:  MOVFF  FF2,0D
0856:  BCF    FF2.7
0858:  ADDWF  FE8,W
085A:  CLRF   FF7
085C:  RLCF   FF7,F
085E:  ADDLW  77
0860:  MOVWF  FF6
0862:  MOVLW  08
0864:  ADDWFC FF7,F
0866:  TBLRD*-
0868:  MOVF   FF5,W
086A:  MOVWF  FFA
086C:  TBLRD*
086E:  MOVF   FF5,W
0870:  BTFSC  0D.7
0872:  BSF    FF2.7
0874:  MOVWF  FF9
0876:  DATA 04,08
0878:  DATA 0A,08
087A:  DATA 12,08
087C:  DATA 1A,08
087E:  DATA 22,08
0880:  DATA 2A,08
0882:  DATA 32,08
0884:  DATA 3A,08
0886:  DATA 42,08
0888:  DATA 4A,08
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #use delay(crystal=20000000) 
*
0334:  CLRF   FEA
0336:  MOVLW  3A
0338:  MOVWF  FE9
033A:  MOVF   FEF,W
033C:  BZ    0358
033E:  MOVLW  06
0340:  MOVWF  01
0342:  CLRF   00
0344:  DECFSZ 00,F
0346:  BRA    0344
0348:  DECFSZ 01,F
034A:  BRA    0342
034C:  MOVLW  7B
034E:  MOVWF  00
0350:  DECFSZ 00,F
0352:  BRA    0350
0354:  DECFSZ FEF,F
0356:  BRA    033E
0358:  RETURN 0
....................  
....................  
.................... // Include I2C_LCD driver source code 
....................  
....................  
.................... #use I2C(master, I2C1, FAST = 100000, STREAM = I2C_LCD) 
*
02FA:  BCF    FC6.7
02FC:  BCF    F9E.3
02FE:  MOVFF  46,FC9
0302:  MOVLW  02
0304:  BTFSC  FC6.7
0306:  BRA    0312
0308:  BTFSS  F9E.3
030A:  BRA    0308
030C:  MOVLW  00
030E:  BTFSC  FC5.6
0310:  MOVLW  01
0312:  MOVWF  01
0314:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
*
0768:  BTFSS  F9E.4
076A:  BRA    0768
076C:  MOVWF  FAD
076E:  RETURN 0
.................... #include <I2C_LCD.c> 
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers) 
.................... // https://simple-circuit.com/ 
....................  
....................  
....................  
.................... #define LCD_BACKLIGHT          0x08 
.................... #define LCD_NOBACKLIGHT        0x00 
.................... #define LCD_FIRST_ROW          0x80 
.................... #define LCD_SECOND_ROW         0xC0 
.................... #define LCD_THIRD_ROW          0x94 
.................... #define LCD_FOURTH_ROW         0xD4 
.................... #define LCD_CLEAR              0x01 
.................... #define LCD_RETURN_HOME        0x02 
.................... #define LCD_ENTRY_MODE_SET     0x04 
.................... #define LCD_CURSOR_OFF         0x0C 
.................... #define LCD_UNDERLINE_ON       0x0E 
.................... #define LCD_BLINK_CURSOR_ON    0x0F 
.................... #define LCD_MOVE_CURSOR_LEFT   0x10 
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14 
.................... #define LCD_TURN_ON            0x0C 
.................... #define LCD_TURN_OFF           0x08 
.................... #define LCD_SHIFT_LEFT         0x18 
.................... #define LCD_SHIFT_RIGHT        0x1E 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
....................  
.................... int1 RS; 
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT; 
....................  
.................... void LCD_Write_Nibble(unsigned int8 n); 
.................... void LCD_Cmd(unsigned int8 Command); 
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row); 
.................... void LCD_Out(unsigned int8 LCD_Char); 
.................... void LCD_Begin(unsigned int8 _i2c_addr); 
.................... void Backlight(); 
.................... void noBacklight(); 
.................... void Expander_Write(unsigned int8 value); 
....................  
.................... void LCD_Write_Nibble(unsigned int8 n) { 
....................   n |= RS; 
*
035A:  MOVLW  00
035C:  BTFSC  16.0
035E:  MOVLW  01
0360:  IORWF  42,F
....................   Expander_Write(n); 
0362:  MOVFF  42,44
0366:  RCALL  0316
....................   Expander_Write(n | 0x04); 
0368:  MOVF   42,W
036A:  IORLW  04
036C:  MOVWF  43
036E:  MOVWF  44
0370:  RCALL  0316
....................   delay_us(1); 
0372:  BRA    0374
0374:  BRA    0376
0376:  NOP   
....................   Expander_Write(n & 0xFB); 
0378:  MOVF   42,W
037A:  ANDLW  FB
037C:  MOVWF  43
037E:  MOVWF  44
0380:  RCALL  0316
....................   delay_us(50); 
0382:  MOVLW  52
0384:  MOVWF  00
0386:  DECFSZ 00,F
0388:  BRA    0386
038A:  BRA    038C
038C:  NOP   
038E:  RETURN 0
.................... } 
....................  
.................... void LCD_Cmd(unsigned int8 Command) { 
....................   RS = 0; 
0390:  BCF    16.0
....................   LCD_Write_Nibble(Command & 0xF0); 
0392:  MOVF   3C,W
0394:  ANDLW  F0
0396:  MOVWF  3D
0398:  MOVWF  42
039A:  RCALL  035A
....................   LCD_Write_Nibble((Command << 4) & 0xF0); 
039C:  SWAPF  3C,W
039E:  MOVWF  00
03A0:  MOVLW  F0
03A2:  ANDWF  00,F
03A4:  MOVF   00,W
03A6:  ANDLW  F0
03A8:  MOVWF  3D
03AA:  MOVWF  42
03AC:  RCALL  035A
03AE:  RETURN 0
.................... } 
....................  
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row) { 
....................   switch(row) { 
*
0422:  MOVF   3A,W
0424:  XORLW  02
0426:  BZ    0432
0428:  XORLW  01
042A:  BZ    0440
042C:  XORLW  07
042E:  BZ    044E
0430:  BRA    045C
....................     case 2: 
....................       LCD_Cmd(0xC0 + col-1); 
0432:  MOVLW  C0
0434:  ADDWF  39,W
0436:  ADDLW  FF
0438:  MOVWF  3B
043A:  MOVWF  3C
043C:  RCALL  0390
....................       break; 
043E:  BRA    0468
....................     case 3: 
....................       LCD_Cmd(0x94 + col-1); 
0440:  MOVLW  94
0442:  ADDWF  39,W
0444:  ADDLW  FF
0446:  MOVWF  3B
0448:  MOVWF  3C
044A:  RCALL  0390
....................       break; 
044C:  BRA    0468
....................     case 4: 
....................       LCD_Cmd(0xD4 + col-1); 
044E:  MOVLW  D4
0450:  ADDWF  39,W
0452:  ADDLW  FF
0454:  MOVWF  3B
0456:  MOVWF  3C
0458:  RCALL  0390
....................     break; 
045A:  BRA    0468
....................     default:      // case 1: 
....................       LCD_Cmd(0x80 + col-1); 
045C:  MOVLW  80
045E:  ADDWF  39,W
0460:  ADDLW  FF
0462:  MOVWF  3B
0464:  MOVWF  3C
0466:  RCALL  0390
....................   } 
0468:  RETURN 0
.................... } 
....................  
.................... void LCD_Out(unsigned int8 LCD_Char){ 
....................   RS = 1; 
046A:  BSF    16.0
....................   LCD_Write_Nibble(LCD_Char & 0xF0); 
046C:  MOVF   40,W
046E:  ANDLW  F0
0470:  MOVWF  41
0472:  MOVWF  42
0474:  RCALL  035A
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0); 
0476:  SWAPF  40,W
0478:  MOVWF  00
047A:  MOVLW  F0
047C:  ANDWF  00,F
047E:  MOVF   00,W
0480:  ANDLW  F0
0482:  MOVWF  41
0484:  MOVWF  42
0486:  RCALL  035A
0488:  RETURN 0
.................... } 
....................  
.................... void LCD_Begin(unsigned int8 _i2c_addr) { 
....................   i2c_addr = _i2c_addr; 
*
03B0:  MOVFF  39,17
....................   Expander_Write(0); 
03B4:  CLRF   44
03B6:  RCALL  0316
....................   delay_ms(40); 
03B8:  MOVLW  28
03BA:  MOVWF  3A
03BC:  RCALL  0334
....................   LCD_Cmd(3); 
03BE:  MOVLW  03
03C0:  MOVWF  3C
03C2:  RCALL  0390
....................   delay_ms(5); 
03C4:  MOVLW  05
03C6:  MOVWF  3A
03C8:  RCALL  0334
....................   LCD_Cmd(3); 
03CA:  MOVLW  03
03CC:  MOVWF  3C
03CE:  RCALL  0390
....................   delay_ms(5); 
03D0:  MOVLW  05
03D2:  MOVWF  3A
03D4:  RCALL  0334
....................   LCD_Cmd(3); 
03D6:  MOVLW  03
03D8:  MOVWF  3C
03DA:  RCALL  0390
....................   delay_ms(5); 
03DC:  MOVLW  05
03DE:  MOVWF  3A
03E0:  RCALL  0334
....................   LCD_Cmd(LCD_RETURN_HOME); 
03E2:  MOVLW  02
03E4:  MOVWF  3C
03E6:  RCALL  0390
....................   delay_ms(5); 
03E8:  MOVLW  05
03EA:  MOVWF  3A
03EC:  RCALL  0334
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2)); 
03EE:  MOVLW  28
03F0:  MOVWF  3C
03F2:  RCALL  0390
....................   delay_ms(50); 
03F4:  MOVLW  32
03F6:  MOVWF  3A
03F8:  RCALL  0334
....................   LCD_Cmd(LCD_TURN_ON); 
03FA:  MOVLW  0C
03FC:  MOVWF  3C
03FE:  RCALL  0390
....................   delay_ms(50); 
0400:  MOVLW  32
0402:  MOVWF  3A
0404:  RCALL  0334
....................   LCD_Cmd(LCD_CLEAR); 
0406:  MOVLW  01
0408:  MOVWF  3C
040A:  RCALL  0390
....................   delay_ms(50); 
040C:  MOVLW  32
040E:  MOVWF  3A
0410:  RCALL  0334
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME); 
0412:  MOVLW  06
0414:  MOVWF  3C
0416:  RCALL  0390
....................   delay_ms(50); 
0418:  MOVLW  32
041A:  MOVWF  3A
041C:  RCALL  0334
041E:  GOTO   0922 (RETURN)
.................... } 
....................  
.................... void Backlight() { 
....................   backlight_val = LCD_BACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................  
.................... void noBacklight() { 
....................   backlight_val = LCD_NOBACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................  
.................... void Expander_Write(unsigned int8 value) { 
....................   I2C_Start(I2C_LCD); 
*
0316:  BSF    FC5.0
0318:  BTFSC  FC5.0
031A:  BRA    0318
....................   I2C_Write(I2C_LCD, i2c_addr); 
031C:  MOVFF  17,46
0320:  RCALL  02FA
....................   I2C_Write(I2C_LCD, value | backlight_val); 
0322:  MOVF   44,W
0324:  IORWF  18,W
0326:  MOVWF  45
0328:  MOVWF  46
032A:  RCALL  02FA
....................   I2C_Stop(I2C_LCD); 
032C:  BSF    FC5.2
032E:  BTFSC  FC5.2
0330:  BRA    032E
0332:  RETURN 0
.................... } 
....................  
.................... #include <Teclado4x4.h> 
.................... ///////////////////////////////////////////////////////////////////////////  
.................... ////                             Flex_KBD.C                            ////  
.................... ////                  Generic keypad scan driver                       ////  
.................... ////                                                                   ////  
.................... ////  kbd_init()   Must be called before any other function.           ////  
.................... ////                                                                   ////  
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not ////  
.................... ////                   This function should be called frequently so as ////  
.................... ////                   not to miss a key press.                        ////  
.................... ////                                                                   ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................  
....................  
.................... //Keypad connection:   
....................  
.................... //Keypad connection:  
.................... #define row0 PIN_B7  
.................... #define row1 PIN_B6  
.................... #define row2 PIN_B4  
.................... #define row3 PIN_B5  
.................... #define col0 PIN_B3  
.................... #define col1 PIN_B2  
.................... #define col2 PIN_B1  
.................... #define col3 PIN_B0  
....................  
....................  
.................... // Keypad layout:  
.................... char const KEYS[4][4] =  
.................... {{'1','2','3','A'},  
....................  {'4','5','6','B'},  
....................  {'7','8','9','C'},  
....................  {'*','0','#','D'}};  
....................  
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33 // Set this number to apx n/333 where  
.................... // n is the number of times you expect  
.................... // to call kbd_getc each second  
....................  
.................... void kbd_init()  
.................... {  
.................... //set_tris_d(0x0F);  
.................... //output_b(0xF0);  
.................... port_b_pullups(true);  
*
05F6:  BCF    FF1.7
.................... output_HIGH(PIN_B0);  
05F8:  BCF    F93.0
05FA:  BSF    F8A.0
05FC:  GOTO   0982 (RETURN)
.................... }  
....................  
.................... short int ALL_ROWS (void)  
.................... {  
.................... if(input (row0) & input (row1) & input (row2) & input (row3))  
*
0622:  BSF    F93.7
0624:  MOVLW  00
0626:  BTFSC  F81.7
0628:  MOVLW  01
062A:  MOVWF  3B
062C:  BSF    F93.6
062E:  MOVLW  00
0630:  BTFSC  F81.6
0632:  MOVLW  01
0634:  ANDWF  3B,F
0636:  BSF    F93.4
0638:  MOVLW  00
063A:  BTFSC  F81.4
063C:  MOVLW  01
063E:  ANDWF  3B,F
0640:  BSF    F93.5
0642:  MOVLW  00
0644:  BTFSC  F81.5
0646:  MOVLW  01
0648:  ANDWF  3B,W
064A:  BZ    0654
....................    return (0);  
064C:  MOVLW  00
064E:  MOVWF  01
0650:  BRA    0658
0652:  BRA    0658
.................... else  
....................    return (1);  
0654:  MOVLW  01
0656:  MOVWF  01
0658:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... char kbd_getc()  
.................... {  
.................... static byte kbd_call_count;  
.................... static short int kbd_down;  
.................... static char last_key;  
.................... static byte col;  
....................  
.................... byte kchar;  
.................... byte row;  
....................  
.................... kchar='\0';  
065A:  CLRF   39
....................  
.................... if(++kbd_call_count>KBD_DEBOUNCE_FACTOR)  
065C:  INCF   19,F
065E:  MOVF   19,W
0660:  SUBLW  21
0662:  BTFSC  FD8.0
0664:  BRA    0734
....................   {  
....................    switch (col)  
0666:  MOVF   1B,W
0668:  ADDLW  FC
066A:  BC    06B8
066C:  ADDLW  04
066E:  GOTO   073C
....................      {  
....................       case 0:  
....................         output_low(col0);  
0672:  BCF    F93.3
0674:  BCF    F8A.3
....................         output_high(col1);  
0676:  BCF    F93.2
0678:  BSF    F8A.2
....................         output_high(col2);  
067A:  BCF    F93.1
067C:  BSF    F8A.1
....................         output_high(col3);  
067E:  BCF    F93.0
0680:  BSF    F8A.0
....................         break;  
0682:  BRA    06B8
....................      
....................       case 1:  
....................         output_high(col0);  
0684:  BCF    F93.3
0686:  BSF    F8A.3
....................         output_low(col1);  
0688:  BCF    F93.2
068A:  BCF    F8A.2
....................         output_high(col2);  
068C:  BCF    F93.1
068E:  BSF    F8A.1
....................         output_high(col3);  
0690:  BCF    F93.0
0692:  BSF    F8A.0
....................         break;  
0694:  BRA    06B8
....................  
....................       case 2:  
....................         output_high(col0);  
0696:  BCF    F93.3
0698:  BSF    F8A.3
....................         output_high(col1);  
069A:  BCF    F93.2
069C:  BSF    F8A.2
....................         output_low(col2);  
069E:  BCF    F93.1
06A0:  BCF    F8A.1
....................         output_high(col3);  
06A2:  BCF    F93.0
06A4:  BSF    F8A.0
....................         break;  
06A6:  BRA    06B8
....................  
....................       case 3:  
....................         output_high(col0);  
06A8:  BCF    F93.3
06AA:  BSF    F8A.3
....................         output_high(col1);  
06AC:  BCF    F93.2
06AE:  BSF    F8A.2
....................         output_high(col2);  
06B0:  BCF    F93.1
06B2:  BSF    F8A.1
....................         output_low(col3);  
06B4:  BCF    F93.0
06B6:  BCF    F8A.0
....................         break;  
....................       }  
....................  
....................    if(kbd_down)  
06B8:  BTFSS  16.1
06BA:  BRA    06CC
....................      {  
....................       if(!ALL_ROWS())  
06BC:  RCALL  0622
06BE:  MOVF   01,F
06C0:  BNZ   06CA
....................         {  
....................          kbd_down=false;  
06C2:  BCF    16.1
....................          kchar=last_key;  
06C4:  MOVFF  1A,39
....................          last_key='\0';  
06C8:  CLRF   1A
....................         }  
....................      }  
06CA:  BRA    0732
....................    else  
....................      {  
....................       if(ALL_ROWS())  
06CC:  RCALL  0622
06CE:  MOVF   01,F
06D0:  BZ    0728
....................         {  
....................          if(!input (row0))  
06D2:  BSF    F93.7
06D4:  BTFSC  F81.7
06D6:  BRA    06DC
....................             row=0;  
06D8:  CLRF   3A
06DA:  BRA    06FE
....................          else if(!input (row1))  
06DC:  BSF    F93.6
06DE:  BTFSC  F81.6
06E0:  BRA    06E8
....................             row=1;  
06E2:  MOVLW  01
06E4:  MOVWF  3A
06E6:  BRA    06FE
....................          else if(!input (row2))  
06E8:  BSF    F93.4
06EA:  BTFSC  F81.4
06EC:  BRA    06F4
....................             row=2;  
06EE:  MOVLW  02
06F0:  MOVWF  3A
06F2:  BRA    06FE
....................          else if(!input (row3))  
06F4:  BSF    F93.5
06F6:  BTFSC  F81.5
06F8:  BRA    06FE
....................             row=3;  
06FA:  MOVLW  03
06FC:  MOVWF  3A
....................  
....................          last_key =KEYS[row][col];  
06FE:  MOVF   3A,W
0700:  MULLW  04
0702:  MOVF   FF3,W
0704:  CLRF   3C
0706:  MOVWF  3B
0708:  CLRF   03
070A:  MOVF   1B,W
070C:  ADDWF  3B,W
070E:  MOVWF  01
0710:  MOVF   3C,W
0712:  ADDWFC 03,F
0714:  MOVF   01,W
0716:  MOVFF  FF2,3B
071A:  BCF    FF2.7
071C:  RCALL  0096
071E:  BTFSC  3B.7
0720:  BSF    FF2.7
0722:  MOVWF  1A
....................          kbd_down = true;  
0724:  BSF    16.1
....................         }  
0726:  BRA    0732
....................       else  
....................         {  
....................          ++col;  
0728:  INCF   1B,F
....................          if(col==4)  
072A:  MOVF   1B,W
072C:  SUBLW  04
072E:  BNZ   0732
....................             col=0;  
0730:  CLRF   1B
....................         }  
....................      }  
....................    kbd_call_count=0;  
0732:  CLRF   19
....................   }  
.................... return(kchar);  
0734:  MOVFF  39,01
0738:  GOTO   09B6 (RETURN)
.................... }  
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... static int m[8];    
.................... static int n[8]; 
.................... int flag = 1,count = 0; 
.................... int vel_dc =5,i=0,vel_step= 5, p; 
.................... char k; 
.................... boolean step_ON =false; 
.................... boolean dc_ON = false; 
.................... boolean step_horario = true; 
....................  
.................... void lcd(){ 
.................... if(step_ON == true){ 
*
057C:  BTFSS  16.2
057E:  BRA    0592
....................  LCD_Goto(11, 1); 
0580:  MOVLW  0B
0582:  MOVWF  39
0584:  MOVLW  01
0586:  MOVWF  3A
0588:  RCALL  0422
.................... printf(lcd_out,"1");     // Print i with 3 numbers max 
058A:  MOVLW  31
058C:  MOVWF  40
058E:  RCALL  046A
.................... }else{ 
0590:  BRA    05A2
.................... LCD_Goto(11, 1); 
0592:  MOVLW  0B
0594:  MOVWF  39
0596:  MOVLW  01
0598:  MOVWF  3A
059A:  RCALL  0422
.................... printf(lcd_out,"0");   
059C:  MOVLW  30
059E:  MOVWF  40
05A0:  RCALL  046A
.................... } 
.................... if(dc_ON == true){ 
05A2:  BTFSS  16.3
05A4:  BRA    05B8
.................... LCD_Goto(10, 2); 
05A6:  MOVLW  0A
05A8:  MOVWF  39
05AA:  MOVLW  02
05AC:  MOVWF  3A
05AE:  RCALL  0422
.................... printf(lcd_out,"1"); 
05B0:  MOVLW  31
05B2:  MOVWF  40
05B4:  RCALL  046A
.................... }else{ 
05B6:  BRA    05C8
.................... LCD_Goto(10, 2); 
05B8:  MOVLW  0A
05BA:  MOVWF  39
05BC:  MOVLW  02
05BE:  MOVWF  3A
05C0:  RCALL  0422
.................... printf(lcd_out,"0"); 
05C2:  MOVLW  30
05C4:  MOVWF  40
05C6:  RCALL  046A
.................... } 
....................  
.................... LCD_Goto(16, 1); 
05C8:  MOVLW  10
05CA:  MOVWF  39
05CC:  MOVLW  01
05CE:  MOVWF  3A
05D0:  RCALL  0422
.................... printf(lcd_out,"%d",vel_step); 
05D2:  MOVFF  36,3A
05D6:  MOVLW  18
05D8:  MOVWF  3B
05DA:  RCALL  04D2
.................... LCD_Goto(16, 2); 
05DC:  MOVLW  10
05DE:  MOVWF  39
05E0:  MOVLW  02
05E2:  MOVWF  3A
05E4:  RCALL  0422
.................... printf(lcd_out,"%d",vel_dc-1); 
05E6:  MOVLW  01
05E8:  SUBWF  34,W
05EA:  MOVWF  39
05EC:  MOVWF  3A
05EE:  MOVLW  18
05F0:  MOVWF  3B
05F2:  RCALL  04D2
05F4:  RETURN 0
....................  
.................... } 
....................  
.................... #INT_RTCC 
.................... void  RTCC_isr(void)  
.................... {   
....................  
....................    if (count < flag){ 
*
00C0:  MOVF   32,W
00C2:  SUBWF  33,W
00C4:  BC    011C
....................       count++; 
00C6:  INCF   33,F
....................           
....................       if(step_horario ==true){ 
00C8:  BTFSS  16.4
00CA:  BRA    00F2
....................     
....................          if(i<4){ 
00CC:  MOVF   35,W
00CE:  SUBLW  03
00D0:  BNC   00EE
....................             output_d(m[i]); 
00D2:  CLRF   03
00D4:  MOVF   35,W
00D6:  ADDLW  22
00D8:  MOVWF  FE9
00DA:  MOVLW  00
00DC:  ADDWFC 03,W
00DE:  MOVWF  FEA
00E0:  MOVFF  FEF,47
00E4:  CLRF   F95
00E6:  MOVFF  47,F8C
....................             i++; 
00EA:  INCF   35,F
....................          }else{ 
00EC:  BRA    00F0
....................             i=0; 
00EE:  CLRF   35
....................          } 
....................       }else if(step_horario == false){ 
00F0:  BRA    011A
00F2:  BTFSC  16.4
00F4:  BRA    011A
....................          if(i<4){ 
00F6:  MOVF   35,W
00F8:  SUBLW  03
00FA:  BNC   0118
....................             output_d(n[i]); 
00FC:  CLRF   03
00FE:  MOVF   35,W
0100:  ADDLW  2A
0102:  MOVWF  FE9
0104:  MOVLW  00
0106:  ADDWFC 03,W
0108:  MOVWF  FEA
010A:  MOVFF  FEF,47
010E:  CLRF   F95
0110:  MOVFF  47,F8C
....................             i++; 
0114:  INCF   35,F
....................       }else{ 
0116:  BRA    011A
....................          i = 0; 
0118:  CLRF   35
....................          } 
....................       } 
....................    }else{ 
011A:  BRA    011E
....................    count = 0; 
011C:  CLRF   33
....................    } 
....................     
....................     
011E:  BCF    FF2.2
0120:  GOTO   0054
.................... } 
....................  
.................... void motor_step(){ 
....................  
.................... if(step_on == false){ 
*
0770:  BTFSC  16.2
0772:  BRA    0786
....................    output_d(0b00000000); 
0774:  CLRF   F95
0776:  CLRF   F8C
....................    fprintf(PORT1,"Desligou motor step\n"); 
0778:  MOVLW  24
077A:  MOVWF  FF6
077C:  MOVLW  01
077E:  MOVWF  FF7
0780:  RCALL  0600
....................    lcd(); 
0782:  RCALL  057C
....................    return;   
0784:  BRA    07BA
....................    } 
....................    //fprintf(PORT1,"Entrou motor step\n"); 
....................    switch(vel_step) 
0786:  MOVLW  01
0788:  SUBWF  36,W
078A:  ADDLW  FB
078C:  BC    07B8
078E:  ADDLW  05
0790:  GOTO   07BC
....................    { 
....................       case 1: 
....................       flag = 1; 
0794:  MOVLW  01
0796:  MOVWF  32
....................        
....................       break; 
0798:  BRA    07B8
....................        
....................       case 2: 
....................       flag = 3; 
079A:  MOVLW  03
079C:  MOVWF  32
....................       ; 
....................       break; 
079E:  BRA    07B8
....................  
....................       case 3: 
....................       flag = 5; 
07A0:  MOVLW  05
07A2:  MOVWF  32
....................        
....................       break; 
07A4:  BRA    07B8
....................  
....................       case 4: 
....................       flag = 25; 
07A6:  MOVLW  19
07A8:  MOVWF  32
....................        
....................       break; 
07AA:  BRA    07B8
....................  
....................       case 5: 
....................       flag = 50; 
07AC:  MOVLW  32
07AE:  MOVWF  32
....................       p=1; 
07B0:  MOVLW  01
07B2:  MOVWF  37
....................       break; 
07B4:  BRA    07B8
....................       lcd(); 
07B6:  RCALL  057C
....................             
....................    } 
....................    //fprintf(PORT1,"valor da flag=%u\n",flag);    
.................... lcd(); 
07B8:  RCALL  057C
07BA:  RETURN 0
.................... } 
....................  
....................  
.................... void motor_dc() 
.................... { 
....................    if(dc_on == false){ 
*
07EA:  BTFSC  16.3
07EC:  BRA    07F6
....................    set_pwm1_duty(0); 
07EE:  CLRF   FBE
....................    set_pwm2_duty(0); 
07F0:  CLRF   FBB
....................    lcd(); 
07F2:  RCALL  057C
....................    return; 
07F4:  BRA    0850
....................    } 
....................    switch(vel_dc) 
07F6:  MOVLW  01
07F8:  SUBWF  34,W
07FA:  ADDLW  F6
07FC:  BC    084E
07FE:  ADDLW  0A
0800:  GOTO   0852
....................    { 
....................       case 1: 
....................       set_pwm1_duty(255); 
0804:  SETF   FBE
....................       set_pwm2_duty(0); 
0806:  CLRF   FBB
....................       break; 
0808:  BRA    084E
....................  
....................       case 2: 
....................       set_pwm1_duty(240); 
080A:  MOVLW  F0
080C:  MOVWF  FBE
....................       set_pwm2_duty(0); 
080E:  CLRF   FBB
....................       break; 
0810:  BRA    084E
....................  
....................       case 3: 
....................       set_pwm1_duty(230); 
0812:  MOVLW  E6
0814:  MOVWF  FBE
....................       set_pwm2_duty(0); 
0816:  CLRF   FBB
....................       break; 
0818:  BRA    084E
....................  
....................       case 4: 
....................       set_pwm1_duty(220); 
081A:  MOVLW  DC
081C:  MOVWF  FBE
....................       set_pwm2_duty(0); 
081E:  CLRF   FBB
....................       break; 
0820:  BRA    084E
....................  
....................       case 5: 
....................       set_pwm1_duty(210); 
0822:  MOVLW  D2
0824:  MOVWF  FBE
....................       set_pwm2_duty(0); 
0826:  CLRF   FBB
....................       break; 
0828:  BRA    084E
....................  
....................       case 6: 
....................       set_pwm1_duty(0); 
082A:  CLRF   FBE
....................       set_pwm2_duty(210); 
082C:  MOVLW  D2
082E:  MOVWF  FBB
....................       break; 
0830:  BRA    084E
....................  
....................       case 7: 
....................       set_pwm1_duty(0); 
0832:  CLRF   FBE
....................       set_pwm2_duty(220); 
0834:  MOVLW  DC
0836:  MOVWF  FBB
....................       break; 
0838:  BRA    084E
....................  
....................       case 8: 
....................       set_pwm1_duty(0); 
083A:  CLRF   FBE
....................       set_pwm2_duty(230); 
083C:  MOVLW  E6
083E:  MOVWF  FBB
....................       break; 
0840:  BRA    084E
....................  
....................       case 9: 
....................       set_pwm1_duty(0); 
0842:  CLRF   FBE
....................       set_pwm2_duty(240); 
0844:  MOVLW  F0
0846:  MOVWF  FBB
....................       break; 
0848:  BRA    084E
....................  
....................       case 10: 
....................       set_pwm1_duty(0); 
084A:  CLRF   FBE
....................       set_pwm2_duty(255); 
084C:  SETF   FBB
....................       break; 
....................    } 
.................... lcd(); 
084E:  RCALL  057C
0850:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
*
088A:  CLRF   FF8
088C:  BCF    FD0.7
088E:  BSF    07.7
0890:  BSF    F94.3
0892:  BSF    F94.4
0894:  MOVLW  31
0896:  MOVWF  FC8
0898:  MOVLW  28
089A:  MOVWF  FC6
089C:  BSF    FC7.7
089E:  BCF    FC7.6
08A0:  MOVLW  81
08A2:  MOVWF  FAF
08A4:  MOVLW  A6
08A6:  MOVWF  FAC
08A8:  MOVLW  90
08AA:  MOVWF  FAB
08AC:  MOVLW  08
08AE:  MOVWF  18
08B0:  MOVLW  01
08B2:  MOVWF  32
08B4:  CLRF   33
08B6:  MOVLW  05
08B8:  MOVWF  34
08BA:  CLRF   35
08BC:  MOVWF  36
08BE:  BCF    16.2
08C0:  BCF    16.3
08C2:  BSF    16.4
08C4:  BSF    FC1.0
08C6:  BSF    FC1.1
08C8:  BSF    FC1.2
08CA:  BCF    FC1.3
08CC:  BCF    16.1
08CE:  CLRF   19
08D0:  BCF    16.1
08D2:  CLRF   1A
08D4:  CLRF   1B
08D6:  CLRF   1C
08D8:  CLRF   1D
08DA:  CLRF   22
08DC:  CLRF   23
08DE:  CLRF   24
08E0:  CLRF   25
08E2:  CLRF   26
08E4:  CLRF   27
08E6:  CLRF   28
08E8:  CLRF   29
08EA:  CLRF   2A
08EC:  CLRF   2B
08EE:  CLRF   2C
08F0:  CLRF   2D
08F2:  CLRF   2E
08F4:  CLRF   2F
08F6:  CLRF   30
08F8:  CLRF   31
.................... { 
....................    k="0"; 
08FA:  MOVLW  30
08FC:  MOVWF  38
....................    n[0] = 0b00000100; 
08FE:  MOVLW  04
0900:  MOVWF  2A
....................    n[1] = 0b00001000; 
0902:  MOVLW  08
0904:  MOVWF  2B
....................    n[2] = 0b00000010;                                                                  
0906:  MOVLW  02
0908:  MOVWF  2C
....................    n[3] = 0b00000001;  
090A:  MOVLW  01
090C:  MOVWF  2D
....................     
....................    m[0] = 0b00000001;                                                                                                                       
090E:  MOVWF  22
....................    m[1] = 0b00000010;       
0910:  MOVLW  02
0912:  MOVWF  23
....................    m[2] = 0b00001000;                                                                                                                       
0914:  MOVLW  08
0916:  MOVWF  24
....................    m[3] = 0b00000100; 
0918:  MOVLW  04
091A:  MOVWF  25
....................     
....................    LCD_Begin(0x4E);                    // Initialize LCD module with I2C address = 0x4E 
091C:  MOVLW  4E
091E:  MOVWF  39
0920:  BRA    03B0
....................   
....................  // LCD_Goto(2, 1);                     // Go to column 2 row 1 
....................   //LCD_Out("Hello, world!"); 
....................     
....................    setup_adc_ports(NO_ANALOGS); 
0922:  BSF    FC1.0
0924:  BSF    FC1.1
0926:  BSF    FC1.2
0928:  BCF    FC1.3
....................    setup_adc(ADC_OFF); 
092A:  BCF    FC2.0
....................    setup_psp(PSP_DISABLED); 
092C:  BCF    F96.4
....................    //setup_spi(SPI_SS_DISABLED); 
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_2); 
092E:  MOVLW  80
0930:  MOVWF  FD5
....................    set_timer0( 63036 ); 
0932:  MOVLW  F6
0934:  MOVWF  FD7
0936:  MOVLW  3C
0938:  MOVWF  FD6
....................    //setup_comparator(NC_NC_NC_NC); 
....................    //setup_vref(FALSE); 
....................    setup_timer_2(T2_DIV_BY_16,255,1);//819 us overflow,819 us interrupt 
093A:  MOVLW  00
093C:  IORLW  06
093E:  MOVWF  FCA
0940:  MOVLW  FF
0942:  MOVWF  FCB
....................     
....................    setup_ccp1(CCP_PWM); 
0944:  BCF    F94.2
0946:  BCF    F8B.2
0948:  MOVLW  0C
094A:  MOVWF  FBD
....................    setup_ccp2(CCP_PWM); 
094C:  BCF    F94.1
094E:  BCF    F8B.1
0950:  MOVWF  FBA
....................    delay_ms(50); 
0952:  MOVLW  32
0954:  MOVWF  3A
0956:  RCALL  0334
....................     
....................     
....................    LCD_Goto(1, 1); 
0958:  MOVLW  01
095A:  MOVWF  39
095C:  MOVWF  3A
095E:  RCALL  0422
....................    LCD_Out("Motor-STEP VEL:");      
0960:  MOVLW  3A
0962:  MOVWF  FF6
0964:  MOVLW  01
0966:  MOVWF  FF7
0968:  RCALL  048A
....................    LCD_Goto(1, 2); 
096A:  MOVLW  01
096C:  MOVWF  39
096E:  MOVLW  02
0970:  MOVWF  3A
0972:  RCALL  0422
....................    LCD_Out("Motor-DC   VEL:"); 
0974:  MOVLW  4A
0976:  MOVWF  FF6
0978:  MOVLW  01
097A:  MOVWF  FF7
097C:  RCALL  048A
....................     
....................    lcd(); 
097E:  RCALL  057C
....................     
....................         
....................     
....................     
....................    kbd_init(); 
0980:  BRA    05F6
....................    printf("Inicializando\n"); 
0982:  MOVLW  5A
0984:  MOVWF  FF6
0986:  MOVLW  01
0988:  MOVWF  FF7
098A:  RCALL  0600
....................    delay_ms(2000); 
098C:  MOVLW  08
098E:  MOVWF  39
0990:  MOVLW  FA
0992:  MOVWF  3A
0994:  RCALL  0334
0996:  DECFSZ 39,F
0998:  BRA    0990
....................    set_pwm1_duty(0); 
099A:  CLRF   FBE
....................    set_pwm2_duty(0); 
099C:  CLRF   FBB
....................    output_low(pin_d0); 
099E:  BCF    F95.0
09A0:  BCF    F8C.0
....................    output_low(pin_d1); 
09A2:  BCF    F95.1
09A4:  BCF    F8C.1
....................    output_low(pin_d2); 
09A6:  BCF    F95.2
09A8:  BCF    F8C.2
....................    output_low(pin_d3); 
09AA:  BCF    F95.3
09AC:  BCF    F8C.3
....................    //enable_interrupts(INT_RTCC); 
....................    enable_interrupts(GLOBAL); 
09AE:  MOVLW  C0
09B0:  IORWF  FF2,F
....................    disable_interrupts(INT_RTCC); 
09B2:  BCF    FF2.5
....................     
....................    while(TRUE) 
....................    { 
....................        
....................  
....................        k=kbd_getc(); 
09B4:  BRA    065A
09B6:  MOVFF  01,38
....................        
....................        
....................       if(k!=0) 
09BA:  MOVF   38,F
09BC:  BTFSC  FD8.2
09BE:  BRA    0AFA
....................       { 
....................          printf("Tecla Pressionada:"); 
09C0:  MOVLW  6A
09C2:  MOVWF  FF6
09C4:  MOVLW  01
09C6:  MOVWF  FF7
09C8:  RCALL  0600
....................          putc(k); 
09CA:  MOVF   38,W
09CC:  RCALL  0768
....................          putc('\n'); 
09CE:  MOVLW  0A
09D0:  RCALL  0768
....................          delay_ms(100); 
09D2:  MOVLW  64
09D4:  MOVWF  3A
09D6:  RCALL  0334
....................           
....................          switch(k) 
09D8:  MOVF   38,W
09DA:  XORLW  31
09DC:  BZ    09FE
09DE:  XORLW  03
09E0:  BZ    0A0C
09E2:  XORLW  01
09E4:  BZ    0A38
09E6:  XORLW  07
09E8:  BZ    0A46
09EA:  XORLW  02
09EC:  BZ    0A66
09EE:  XORLW  01
09F0:  BZ    0A88
09F2:  XORLW  0F
09F4:  BZ    0AA8
09F6:  XORLW  01
09F8:  BTFSC  FD8.2
09FA:  BRA    0ACE
09FC:  BRA    0AF0
....................          { 
....................           
....................             case '1': 
....................             step_horario = false; 
09FE:  BCF    16.4
....................             fprintf(PORT1, "Movimento anti-horario"); 
0A00:  MOVLW  7E
0A02:  MOVWF  FF6
0A04:  MOVLW  01
0A06:  MOVWF  FF7
0A08:  RCALL  0600
....................             break; 
0A0A:  BRA    0AFA
....................              
....................              case '2': 
....................             if(step_on == true){ 
0A0C:  BTFSS  16.2
0A0E:  BRA    0A20
....................             step_on = false; 
0A10:  BCF    16.2
....................             disable_interrupts(INT_RTCC); 
0A12:  BCF    FF2.5
....................             fprintf(PORT1,"Desligando motor step\n"); 
0A14:  MOVLW  96
0A16:  MOVWF  FF6
0A18:  MOVLW  01
0A1A:  MOVWF  FF7
0A1C:  RCALL  0600
....................             }else if(step_on == false){ 
0A1E:  BRA    0A34
0A20:  BTFSC  16.2
0A22:  BRA    0A34
....................              
....................             step_on = true; 
0A24:  BSF    16.2
....................             i=0; 
0A26:  CLRF   35
....................             enable_interrupts(INT_RTCC); 
0A28:  BSF    FF2.5
....................             fprintf(PORT1,"Ligando motor step\n");} 
0A2A:  MOVLW  AE
0A2C:  MOVWF  FF6
0A2E:  MOVLW  01
0A30:  MOVWF  FF7
0A32:  RCALL  0600
....................             motor_step(); 
0A34:  RCALL  0770
....................             break; 
0A36:  BRA    0AFA
....................              
....................             case '3': 
....................             step_horario = true; 
0A38:  BSF    16.4
....................             fprintf(PORT1, "Movimento horrio"); 
0A3A:  MOVLW  C2
0A3C:  MOVWF  FF6
0A3E:  MOVLW  01
0A40:  MOVWF  FF7
0A42:  RCALL  0600
....................             break; 
0A44:  BRA    0AFA
....................              
....................             case '4': 
....................             if(vel_step==1) 
0A46:  DECFSZ 36,W
0A48:  BRA    0A56
....................             { 
....................                fprintf(PORT1,"Velocidade step Minima alcancada\n"); 
0A4A:  MOVLW  D4
0A4C:  MOVWF  FF6
0A4E:  MOVLW  01
0A50:  MOVWF  FF7
0A52:  RCALL  0600
....................                break; 
0A54:  BRA    0AFA
....................             } 
....................  
....................             fprintf(PORT1,"Diminuindo step velocidade\n"); 
0A56:  MOVLW  F6
0A58:  MOVWF  FF6
0A5A:  MOVLW  01
0A5C:  MOVWF  FF7
0A5E:  RCALL  0600
....................             vel_step--; 
0A60:  DECF   36,F
....................             motor_step(); 
0A62:  RCALL  0770
....................              
....................             break; 
0A64:  BRA    0AFA
....................              
....................             case '6': 
....................             if(vel_step==5) 
0A66:  MOVF   36,W
0A68:  SUBLW  05
0A6A:  BNZ   0A78
....................             { 
....................                fprintf(PORT1,"Velocidade step Maxima alcancada\n"); 
0A6C:  MOVLW  12
0A6E:  MOVWF  FF6
0A70:  MOVLW  02
0A72:  MOVWF  FF7
0A74:  RCALL  0600
....................                break; 
0A76:  BRA    0AFA
....................             } 
....................  
....................             fprintf(PORT1,"Aumentando step velocidade\n"); 
0A78:  MOVLW  34
0A7A:  MOVWF  FF6
0A7C:  MOVLW  02
0A7E:  MOVWF  FF7
0A80:  RCALL  0600
....................             vel_step++; 
0A82:  INCF   36,F
....................             motor_step(); 
0A84:  RCALL  0770
....................             break;         
0A86:  BRA    0AFA
....................              
....................             case '7': 
....................             if(vel_dc==1) 
0A88:  DECFSZ 34,W
0A8A:  BRA    0A98
....................             { 
....................                fprintf(PORT1,"Velocidade maxima anti-horaria alcancada\n"); 
0A8C:  MOVLW  50
0A8E:  MOVWF  FF6
0A90:  MOVLW  02
0A92:  MOVWF  FF7
0A94:  RCALL  0600
....................                break; 
0A96:  BRA    0AFA
....................             } 
....................  
....................             fprintf(PORT1,"Diminuindo velocidade\n"); 
0A98:  MOVLW  7A
0A9A:  MOVWF  FF6
0A9C:  MOVLW  02
0A9E:  MOVWF  FF7
0AA0:  RCALL  0600
....................             vel_dc--; 
0AA2:  DECF   34,F
....................             motor_dc(); 
0AA4:  RCALL  07EA
....................             break; 
0AA6:  BRA    0AFA
....................              
....................             case '8': 
....................             if(dc_on == true){ 
0AA8:  BTFSS  16.3
0AAA:  BRA    0ABA
....................             dc_on = false; 
0AAC:  BCF    16.3
....................             fprintf(PORT1,"Desligando motor\n"); 
0AAE:  MOVLW  92
0AB0:  MOVWF  FF6
0AB2:  MOVLW  02
0AB4:  MOVWF  FF7
0AB6:  RCALL  0600
....................             }else if(dc_on == false){ 
0AB8:  BRA    0ACA
0ABA:  BTFSC  16.3
0ABC:  BRA    0ACA
....................             dc_on = true; 
0ABE:  BSF    16.3
....................             fprintf(PORT1,"Ligando motor\n"); 
0AC0:  MOVLW  A4
0AC2:  MOVWF  FF6
0AC4:  MOVLW  02
0AC6:  MOVWF  FF7
0AC8:  RCALL  0600
....................             } 
....................             motor_dc(); 
0ACA:  RCALL  07EA
....................             break; 
0ACC:  BRA    0AFA
....................              
....................             case '9': 
....................              
....................             if(vel_dc==10) 
0ACE:  MOVF   34,W
0AD0:  SUBLW  0A
0AD2:  BNZ   0AE0
....................             { 
....................                fprintf(PORT1,"Velocidade maxima horaria alcancada\n"); 
0AD4:  MOVLW  B4
0AD6:  MOVWF  FF6
0AD8:  MOVLW  02
0ADA:  MOVWF  FF7
0ADC:  RCALL  0600
....................                break; 
0ADE:  BRA    0AFA
....................             } 
....................  
....................             fprintf(PORT1,"Aumentando velocidade\n"); 
0AE0:  MOVLW  DA
0AE2:  MOVWF  FF6
0AE4:  MOVLW  02
0AE6:  MOVWF  FF7
0AE8:  RCALL  0600
....................             vel_dc++; 
0AEA:  INCF   34,F
....................             motor_dc(); 
0AEC:  RCALL  07EA
....................             break; 
0AEE:  BRA    0AFA
....................  
....................             default: 
....................             fprintf(PORT1,"ERRO!\n"); 
0AF0:  MOVLW  F2
0AF2:  MOVWF  FF6
0AF4:  MOVLW  02
0AF6:  MOVWF  FF7
0AF8:  RCALL  0600
....................             break; 
....................          } 
....................  
....................       } 
0AFA:  BRA    09B4
....................        
....................        
....................        
....................    } 
.................... } 
....................  
0AFC:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
